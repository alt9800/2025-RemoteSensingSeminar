<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPX Analyzer</title>
    <script src='https://unpkg.com/maplibre-gl@4.0.0/dist/maplibre-gl.js'></script>
    <link href='https://unpkg.com/maplibre-gl@4.0.0/dist/maplibre-gl.css' rel='stylesheet' />
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: #fff;
        }
        
        #container {
            display: flex;
            height: 100vh;
        }
        
        #sidebar {
            width: 350px;
            background: #2a2a2a;
            padding: 20px;
            overflow-y: auto;
            box-shadow: 2px 0 10px rgba(0,0,0,0.5);
        }
        
        #map {
            flex: 1;
            position: relative;
        }
        
        #dropzone {
            border: 2px dashed #4a9eff;
            border-radius: 10px;
            padding: 30px;
            text-align: center;
            margin-bottom: 20px;
            background: rgba(74, 158, 255, 0.1);
            transition: all 0.3s ease;
        }
        
        #dropzone:hover {
            background: rgba(74, 158, 255, 0.2);
            border-color: #6ab3ff;
        }
        
        #dropzone.dragover {
            background: rgba(74, 158, 255, 0.3);
            border-color: #8ac4ff;
            transform: scale(1.02);
        }
        
        .stats {
            background: #333;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            padding: 5px 0;
            border-bottom: 1px solid #444;
        }
        
        .stat-label {
            color: #aaa;
        }
        
        .stat-value {
            color: #4a9eff;
            font-weight: bold;
        }
        
        #dataTable {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 12px;
        }
        
        #dataTable th, #dataTable td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #444;
        }
        
        #dataTable th {
            background: #333;
            color: #4a9eff;
            position: sticky;
            top: 0;
        }
        
        #dataTable tr:hover {
            background: rgba(74, 158, 255, 0.1);
        }
        
        .controls {
            margin: 20px 0;
        }
        
        button {
            background: #4a9eff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin-right: 10px;
            transition: all 0.3s ease;
        }
        
        button:hover {
            background: #6ab3ff;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(74, 158, 255, 0.3);
        }
        
        button:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
        }
        
        input[type="range"] {
            width: 100%;
            margin: 10px 0;
        }
        
        .speed-control {
            margin: 15px 0;
        }
        
        .glow-marker {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: radial-gradient(circle, #fff 0%, #4a9eff 40%, transparent 70%);
            box-shadow: 0 0 20px #4a9eff, 0 0 40px #4a9eff, 0 0 60px #4a9eff;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% {
                box-shadow: 0 0 20px #4a9eff, 0 0 40px #4a9eff, 0 0 60px #4a9eff;
            }
            50% {
                box-shadow: 0 0 30px #4a9eff, 0 0 50px #4a9eff, 0 0 70px #4a9eff;
            }
            100% {
                box-shadow: 0 0 20px #4a9eff, 0 0 40px #4a9eff, 0 0 60px #4a9eff;
            }
        }
        
        h3 {
            color: #4a9eff;
            margin-top: 20px;
        }
        
        .elevation-chart {
            height: 150px;
            background: #333;
            border-radius: 8px;
            margin: 20px 0;
            position: relative;
            overflow: hidden;
        }
        
        .elevation-profile {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 100%;
            background: linear-gradient(to top, #4a9eff22, #4a9eff44);
            clip-path: polygon(var(--elevation-path));
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="sidebar">
            <h2 style="text-align: center; color: #4a9eff;">GPX Analyzer</h2>
            
            <div id="dropzone">
                <p>📁 GPXファイルをドロップ<br>または<br>クリックして選択</p>
                <input type="file" id="fileInput" accept=".gpx" style="display: none;">
            </div>
            
            <div id="stats" class="stats" style="display: none;">
                <h3>📊 統計情報</h3>
                <div class="stat-item">
                    <span class="stat-label">総距離</span>
                    <span class="stat-value" id="totalDistance">-</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">総時間</span>
                    <span class="stat-value" id="totalTime">-</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">平均速度</span>
                    <span class="stat-value" id="avgSpeed">-</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">最高標高</span>
                    <span class="stat-value" id="maxElevation">-</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">最低標高</span>
                    <span class="stat-value" id="minElevation">-</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">累積上昇</span>
                    <span class="stat-value" id="totalAscent">-</span>
                </div>
            </div>
            
            <div class="controls" style="display: none;">
                <h3>🎮 アニメーション制御</h3>
                <button id="playBtn">▶️ 再生</button>
                <button id="pauseBtn" disabled>⏸️ 一時停止</button>
                <button id="resetBtn">🔄 リセット</button>
                
                <div class="speed-control">
                    <label>速度: <span id="speedValue">1</span>x</label>
                    <input type="range" id="speedSlider" min="0.1" max="10" step="0.1" value="1">
                </div>
            </div>
            
            <div id="elevationChart" class="elevation-chart" style="display: none;">
                <h3 style="position: absolute; top: 10px; left: 15px; margin: 0;">📈 標高プロファイル</h3>
                <div class="elevation-profile"></div>
            </div>
            
            <div id="tableContainer" style="display: none;">
                <h3>📋 トラックポイント</h3>
                <div style="max-height: 300px; overflow-y: auto;">
                    <table id="dataTable">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>時刻</th>
                                <th>緯度</th>
                                <th>経度</th>
                                <th>標高(m)</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>
        </div>
        
        <div id="map"></div>
    </div>
    
    <script>
        // Initialize map
        const map = new maplibregl.Map({
            container: 'map',
            style: {
                version: 8,
                sources: {
                    osm: {
                        type: 'raster',
                        tiles: ['https://tile.openstreetmap.jp/styles/osm-bright-ja/{z}/{x}/{y}.png'],
                        tileSize: 256,
                        attribution: '© OpenStreetMap contributors'
                    }
                },
                layers: [{
                    id: 'osm',
                    type: 'raster',
                    source: 'osm'
                }]
            },
            center: [139.7, 35.6],
            zoom: 10
        });
        
        // Global variables
        let gpxData = null;
        let animationId = null;
        let currentIndex = 0;
        let marker = null;
        let isPlaying = false;
        let animationSpeed = 1;
        
        // File handling
        const dropzone = document.getElementById('dropzone');
        const fileInput = document.getElementById('fileInput');
        
        dropzone.addEventListener('click', () => fileInput.click());
        
        dropzone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropzone.classList.add('dragover');
        });
        
        dropzone.addEventListener('dragleave', () => {
            dropzone.classList.remove('dragover');
        });
        
        dropzone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropzone.classList.remove('dragover');
            
            const file = e.dataTransfer.files[0];
            if (file && file.name.endsWith('.gpx')) {
                loadGPXFile(file);
            }
        });
        
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                loadGPXFile(file);
            }
        });
        
        function loadGPXFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                parseGPX(e.target.result);
            };
            reader.readAsText(file);
        }
        
        function parseGPX(xmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(xmlString, 'text/xml');
            
            // Extract track points
            const trackPoints = [];
            const trkpts = doc.getElementsByTagName('trkpt');
            
            for (let i = 0; i < trkpts.length; i++) {
                const pt = trkpts[i];
                const lat = parseFloat(pt.getAttribute('lat'));
                const lon = parseFloat(pt.getAttribute('lon'));
                const eleNode = pt.getElementsByTagName('ele')[0];
                const timeNode = pt.getElementsByTagName('time')[0];
                
                trackPoints.push({
                    lat: lat,
                    lon: lon,
                    ele: eleNode ? parseFloat(eleNode.textContent) : 0,
                    time: timeNode ? new Date(timeNode.textContent) : null
                });
            }
            
            if (trackPoints.length > 0) {
                gpxData = trackPoints;
                displayGPXData();
            }
        }
        
        function displayGPXData() {
            // Clear existing layers
            if (map.getLayer('route')) {
                map.removeLayer('route');
                map.removeSource('route');
            }
            
            // Create GeoJSON from GPX data
            const coordinates = gpxData.map(pt => [pt.lon, pt.lat]);
            
            map.addSource('route', {
                type: 'geojson',
                data: {
                    type: 'Feature',
                    geometry: {
                        type: 'LineString',
                        coordinates: coordinates
                    }
                }
            });
            
            map.addLayer({
                id: 'route',
                type: 'line',
                source: 'route',
                layout: {
                    'line-join': 'round',
                    'line-cap': 'round'
                },
                paint: {
                    'line-color': '#4a9eff',
                    'line-width': 4,
                    'line-opacity': 0.8
                }
            });
            
            // Fit map to bounds
            const bounds = coordinates.reduce((bounds, coord) => {
                return bounds.extend(coord);
            }, new maplibregl.LngLatBounds(coordinates[0], coordinates[0]));
            
            map.fitBounds(bounds, { padding: 50 });
            
            // Display statistics
            displayStatistics();
            
            // Display table
            displayTable();
            
            // Create elevation profile
            createElevationProfile();
            
            // Show controls
            document.getElementById('stats').style.display = 'block';
            document.querySelector('.controls').style.display = 'block';
            document.getElementById('tableContainer').style.display = 'block';
            document.getElementById('elevationChart').style.display = 'block';
            
            // Initialize marker
            if (marker) {
                marker.remove();
            }
            
            const el = document.createElement('div');
            el.className = 'glow-marker';
            
            marker = new maplibregl.Marker(el)
                .setLngLat([gpxData[0].lon, gpxData[0].lat])
                .addTo(map);
        }
        
        function displayStatistics() {
            let totalDistance = 0;
            let totalAscent = 0;
            let minEle = Infinity;
            let maxEle = -Infinity;
            
            for (let i = 1; i < gpxData.length; i++) {
                const dist = calculateDistance(
                    gpxData[i-1].lat, gpxData[i-1].lon,
                    gpxData[i].lat, gpxData[i].lon
                );
                totalDistance += dist;
                
                if (gpxData[i].ele > gpxData[i-1].ele) {
                    totalAscent += gpxData[i].ele - gpxData[i-1].ele;
                }
                
                minEle = Math.min(minEle, gpxData[i].ele);
                maxEle = Math.max(maxEle, gpxData[i].ele);
            }
            
            const totalTime = gpxData[gpxData.length-1].time - gpxData[0].time;
            const avgSpeed = totalDistance / (totalTime / 1000 / 3600);
            
            document.getElementById('totalDistance').textContent = (totalDistance / 1000).toFixed(2) + ' km';
            document.getElementById('totalTime').textContent = formatTime(totalTime);
            document.getElementById('avgSpeed').textContent = avgSpeed.toFixed(1) + ' km/h';
            document.getElementById('maxElevation').textContent = maxEle.toFixed(0) + ' m';
            document.getElementById('minElevation').textContent = minEle.toFixed(0) + ' m';
            document.getElementById('totalAscent').textContent = totalAscent.toFixed(0) + ' m';
        }
        
        function displayTable() {
            const tbody = document.querySelector('#dataTable tbody');
            tbody.innerHTML = '';
            
            gpxData.forEach((pt, i) => {
                const row = tbody.insertRow();
                row.insertCell(0).textContent = i + 1;
                row.insertCell(1).textContent = pt.time ? pt.time.toLocaleTimeString() : '-';
                row.insertCell(2).textContent = pt.lat.toFixed(6);
                row.insertCell(3).textContent = pt.lon.toFixed(6);
                row.insertCell(4).textContent = pt.ele.toFixed(1);
            });
        }
        
        function createElevationProfile() {
            const points = [];
            let totalDist = 0;
            let maxEle = Math.max(...gpxData.map(pt => pt.ele));
            let minEle = Math.min(...gpxData.map(pt => pt.ele));
            
            points.push('0,100');
            
            for (let i = 0; i < gpxData.length; i++) {
                if (i > 0) {
                    totalDist += calculateDistance(
                        gpxData[i-1].lat, gpxData[i-1].lon,
                        gpxData[i].lat, gpxData[i].lon
                    );
                }
                
                const x = (i / (gpxData.length - 1)) * 100;
                const y = 100 - ((gpxData[i].ele - minEle) / (maxEle - minEle)) * 90;
                points.push(`${x},${y}`);
            }
            
            points.push('100,100');
            
            const elevationPath = points.join(' ');
            document.querySelector('.elevation-profile').style.setProperty('--elevation-path', elevationPath);
        }
        
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371000; // Earth radius in meters
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        function formatTime(ms) {
            const hours = Math.floor(ms / 3600000);
            const minutes = Math.floor((ms % 3600000) / 60000);
            const seconds = Math.floor((ms % 60000) / 1000);
            return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        
        // Animation controls
        document.getElementById('playBtn').addEventListener('click', () => {
            isPlaying = true;
            document.getElementById('playBtn').disabled = true;
            document.getElementById('pauseBtn').disabled = false;
            animate();
        });
        
        document.getElementById('pauseBtn').addEventListener('click', () => {
            isPlaying = false;
            document.getElementById('playBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        });
        
        document.getElementById('resetBtn').addEventListener('click', () => {
            currentIndex = 0;
            isPlaying = false;
            document.getElementById('playBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            if (marker && gpxData) {
                marker.setLngLat([gpxData[0].lon, gpxData[0].lat]);
            }
        });
        
        document.getElementById('speedSlider').addEventListener('input', (e) => {
            animationSpeed = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = animationSpeed.toFixed(1);
        });
        
        function animate() {
            if (!isPlaying || !gpxData || currentIndex >= gpxData.length - 1) {
                if (currentIndex >= gpxData.length - 1) {
                    // Animation completed
                    currentIndex = 0;
                    isPlaying = false;
                    document.getElementById('playBtn').disabled = false;
                    document.getElementById('pauseBtn').disabled = true;
                }
                return;
            }
            
            const point = gpxData[currentIndex];
            marker.setLngLat([point.lon, point.lat]);
            
            // Smooth camera follow (optional)
            if (currentIndex % 10 === 0) {
                map.panTo([point.lon, point.lat], { duration: 1000 });
            }
            
            currentIndex += Math.ceil(animationSpeed);
            if (currentIndex >= gpxData.length) {
                currentIndex = gpxData.length - 1;
            }
            
            animationId = requestAnimationFrame(animate);
        }
        
        // Add navigation control
        map.addControl(new maplibregl.NavigationControl());
    </script>
</body>
</html>